//! # Data Models
//!
//! This module defines all the data structures used throughout the Locate918 API.
//! These structs serve multiple purposes:
//! - Database row mapping (via SQLx's FromRow)
//! - JSON serialization for API responses (via Serde's Serialize)
//! - JSON deserialization for API requests (via Serde's Deserialize)
//!
//! ## Naming Convention
//! - `Thing` - Full database record (used in responses)
//! - `CreateThing` - Request payload for creating new records (no id/timestamps)
//!
//! ## Owner
//! Will (Coordinator/Backend Lead)

// =============================================================================
// IMPORTS
// =============================================================================

use chrono::{DateTime, Utc};           // Timestamp handling (timezone-aware)
use serde::{Deserialize, Serialize};   // JSON serialization/deserialization
use sqlx::FromRow;                     // Maps database rows to structs
use uuid::Uuid;                        // Universally unique identifiers

// =============================================================================
// EVENT MODELS
// =============================================================================
// Events are the core data type - they represent local happenings that users
// want to discover. Events are created either manually (for testing) or by
// Skylar's scraper service (in production).

/// Represents an event in the database.
///
/// # Database Table
/// `events` - See migrations/001_initial.sql
///
/// # Derives
/// - `Debug`: Allows printing for debugging
/// - `Serialize`: Converts to JSON for API responses
/// - `Deserialize`: Converts from JSON (used in some internal operations)
/// - `FromRow`: Maps database rows to this struct automatically
///
/// # Example JSON
/// ```json
/// {
///   "id": "550e8400-e29b-41d4-a716-446655440000",
///   "title": "Jazz Night at The Blue Note",
///   "description": "Live jazz music featuring local artists",
///   "location": "Downtown Tulsa",
///   "venue": "The Blue Note",
///   "source_url": "https://thebluenote.com/events/jazz-night",
///   "start_time": "2026-01-25T20:00:00Z",
///   "end_time": "2026-01-25T23:00:00Z",
///   "category": "music",
///   "created_at": "2026-01-17T12:00:00Z"
/// }
/// ```
#[derive(Debug, Serialize, Deserialize, FromRow)]
pub struct Event {
    /// Unique identifier (UUID v4, generated by server)
    pub id: Uuid,

    /// Event title/name (required)
    /// Example: "OSU Basketball vs Kansas"
    pub title: String,

    /// Detailed description of the event (optional)
    /// May contain info about performers, agenda, dress code, etc.
    pub description: Option<String>,

    /// General location/area (optional)
    /// Example: "Downtown Tulsa", "Stillwater, OK"
    pub location: Option<String>,

    /// Specific venue name (optional)
    /// Example: "Gallagher-Iba Arena", "The Blue Note"
    pub venue: Option<String>,

    /// URL to the original event listing (required)
    /// We always link back to the source to respect content ownership
    pub source_url: String,

    /// When the event starts (required, UTC timezone)
    pub start_time: DateTime<Utc>,

    /// When the event ends (optional, UTC timezone)
    /// Some events don't have a defined end time
    pub end_time: Option<DateTime<Utc>>,

    /// Event category for filtering (optional)
    /// Examples: "music", "sports", "food", "arts", "community", "nightlife"
    /// Used by search and LLM for personalization
    pub category: Option<String>,

    /// When this record was created in our database (auto-generated)
    pub created_at: DateTime<Utc>,
}

/// Request payload for creating a new event.
///
/// # Differences from Event
/// - No `id` field (server generates it)
/// - No `created_at` field (server generates it)
///
/// # Usage
/// ```text
/// POST /api/events
/// Content-Type: application/json
///
/// {
///   "title": "Jazz Night",
///   "source_url": "https://example.com/event",
///   "start_time": "2026-01-25T20:00:00Z",
///   "category": "music"
/// }
/// ```
#[derive(Debug, Deserialize)]
pub struct CreateEvent {
    pub title: String,                    // Required
    pub description: Option<String>,      // Optional
    pub location: Option<String>,         // Optional
    pub venue: Option<String>,            // Optional
    pub source_url: String,               // Required - always link to source
    pub start_time: DateTime<Utc>,        // Required
    pub end_time: Option<DateTime<Utc>>,  // Optional
    pub category: Option<String>,         // Optional but recommended
}

// =============================================================================
// USER MODELS
// =============================================================================
// Users represent people using the Locate918 app. User data powers
// personalization - the LLM uses preferences and interaction history
// to make relevant recommendations.

/// Represents a user account in the database.
///
/// # Database Table
/// `users` - See migrations/001_initial.sql
///
/// # Privacy Note
/// In production, consider what user data you actually need to store.
/// Email is used for account identification; name and location are
/// optional and used for personalization.
///
/// # Example JSON
/// ```json
/// {
///   "id": "94c99eb0-21f3-4f7e-afee-f533b964a2d4",
///   "email": "will@example.com",
///   "name": "Will",
///   "location_preference": "downtown",
///   "created_at": "2026-01-17T19:34:01Z"
/// }
/// ```
#[derive(Debug, Serialize, Deserialize, FromRow)]
pub struct User {
    /// Unique identifier (UUID v4, generated by server)
    pub id: Uuid,

    /// User's email address (required, unique)
    /// Used for account identification
    pub email: String,

    /// Display name (optional)
    pub name: Option<String>,

    /// Preferred location/area for events (optional)
    /// Examples: "downtown", "midtown", "south tulsa"
    /// LLM uses this to prioritize nearby events
    pub location_preference: Option<String>,

    /// When the account was created
    pub created_at: DateTime<Utc>,
}

/// Request payload for creating a new user.
///
/// # Usage
/// ```text
/// POST /api/users
/// Content-Type: application/json
///
/// {
///   "email": "newuser@example.com",
///   "name": "John",
///   "location_preference": "downtown"
/// }
/// ```
#[derive(Debug, Deserialize)]
pub struct CreateUser {
    pub email: String,                      // Required, must be unique
    pub name: Option<String>,               // Optional
    pub location_preference: Option<String>, // Optional
}

// =============================================================================
// USER PREFERENCE MODELS
// =============================================================================
// Preferences track what categories a user likes or dislikes.
// This is EXPLICIT preference data - the user told us directly.
// Example: User clicks "I like music" -> preference with weight +5

/// Represents a user's preference for a category.
///
/// # Database Table
/// `user_preferences` - See migrations/001_initial.sql
///
/// # Weight Scale (Recommended)
/// ```text
/// +5  = Love it (always show me this)
/// +3  = Like it
/// +1  = Somewhat interested
///  0  = Neutral (why have a preference?)
/// -1  = Somewhat disinterested
/// -3  = Dislike
/// -5  = Hate it (never show me this)
/// ```
///
/// # How the LLM Uses This
/// When generating recommendations, the LLM sees:
/// - "User has music: +5" -> prioritize music events
/// - "User has sports: -2" -> deprioritize sports events
///
/// # Example JSON
/// ```json
/// {
///   "id": "f15b9bc7-208b-45a7-85ce-89d1f58501df",
///   "user_id": "94c99eb0-21f3-4f7e-afee-f533b964a2d4",
///   "category": "music",
///   "weight": 5,
///   "created_at": "2026-01-17T19:34:39Z"
/// }
/// ```
#[derive(Debug, Serialize, Deserialize, FromRow)]
pub struct UserPreference {
    /// Unique identifier for this preference record
    pub id: Uuid,

    /// Which user this preference belongs to
    pub user_id: Uuid,

    /// The category (e.g., "music", "sports", "food")
    /// Should match categories used in Event.category
    pub category: String,

    /// How much the user likes (+) or dislikes (-) this category
    /// Recommended range: -5 to +5
    pub weight: i32,

    /// When this preference was created/updated
    pub created_at: DateTime<Utc>,
}

/// Request payload for adding/updating a preference.
///
/// # Behavior
/// - If user doesn't have a preference for this category: creates one
/// - If user already has a preference: updates the weight
///
/// # Usage
/// ```text
/// POST /api/users/:id/preferences
/// Content-Type: application/json
///
/// { "category": "music", "weight": 5 }
/// ```
#[derive(Debug, Deserialize)]
pub struct CreateUserPreference {
    pub category: String,  // Category name (e.g., "music")
    pub weight: i32,       // Preference strength (-5 to +5 recommended)
}

// =============================================================================
// USER INTERACTION MODELS
// =============================================================================
// Interactions track what events a user has engaged with.
// This is IMPLICIT preference data - inferred from behavior.
// Example: User views 10 music events -> probably likes music

/// Represents a user's interaction with an event.
///
/// # Database Table
/// `user_interactions` - See migrations/001_initial.sql
///
/// # Interaction Types
/// - `"view"` - User opened the event details page
/// - `"save"` - User saved/bookmarked the event
/// - `"attend"` - User marked as attending / bought tickets
/// - `"dismiss"` - User clicked "not interested" / hid the event
///
/// # How the LLM Uses This
/// Pattern recognition from interaction history:
/// - Lots of "view" on music events -> interested in music
/// - "dismiss" on sports events -> not interested in sports
/// - "attend" events at specific venue -> likes that venue
///
/// # Example JSON
/// ```json
/// {
///   "id": "a1b2c3d4-...",
///   "user_id": "94c99eb0-...",
///   "event_id": "550e8400-...",
///   "interaction_type": "view",
///   "created_at": "2026-01-17T20:00:00Z"
/// }
/// ```
#[derive(Debug, Serialize, Deserialize, FromRow)]
pub struct UserInteraction {
    /// Unique identifier for this interaction record
    pub id: Uuid,

    /// Which user performed the interaction
    pub user_id: Uuid,

    /// Which event they interacted with
    pub event_id: Uuid,

    /// Type of interaction: "view", "save", "attend", "dismiss"
    pub interaction_type: String,

    /// When the interaction occurred
    pub created_at: DateTime<Utc>,
}

/// Request payload for recording an interaction.
///
/// # Usage
/// ```text
/// POST /api/users/:id/interactions
/// Content-Type: application/json
///
/// {
///   "event_id": "550e8400-e29b-41d4-a716-446655440000",
///   "interaction_type": "view"
/// }
/// ```
///
/// # When to Record Interactions
/// - "view": When user opens event detail page
/// - "save": When user clicks save/bookmark button
/// - "attend": When user clicks "I'm going" or completes ticket purchase
/// - "dismiss": When user clicks "not interested" or hides event
#[derive(Debug, Deserialize)]
pub struct CreateUserInteraction {
    pub event_id: Uuid,           // Which event
    pub interaction_type: String,  // What they did: "view", "save", "attend", "dismiss"
}

// =============================================================================
// COMPOSITE MODELS (FOR LLM CONTEXT)
// =============================================================================
// These models combine data from multiple tables to give the LLM
// all the context it needs for personalization in a single request.

/// Complete user profile for LLM personalization.
///
/// # Purpose
/// This is the primary data structure Ben's LLM integration will use.
/// When a user asks "What should I do this weekend?", the chat endpoint
/// fetches this profile to understand the user's preferences and history.
///
/// # Endpoint
/// `GET /api/users/:id/profile`
///
/// # Contains
/// - Basic user info (name, location preference)
/// - All category preferences (explicit likes/dislikes)
/// - Recent 20 interactions with event details (implicit preferences)
///
/// # Example Usage in LLM Prompt
/// ```text
/// System: You are helping a user find events.
///
/// User Profile:
/// - Name: Will
/// - Location Preference: downtown
/// - Likes: music (+5), food (+3)
/// - Dislikes: sports (-2)
/// - Recent Activity: Viewed "Jazz Night", Saved "Food Truck Festival"
///
/// User Query: "What's happening this weekend?"
///
/// [LLM generates personalized recommendations based on profile]
/// ```
#[derive(Debug, Serialize)]
pub struct UserProfile {
    /// Basic user information
    pub user: User,

    /// All category preferences (explicit)
    /// Example: [{ category: "music", weight: 5 }, { category: "sports", weight: -2 }]
    pub preferences: Vec<UserPreference>,

    /// Recent interactions with event details (implicit)
    /// Limited to 20 most recent to keep payload reasonable
    pub recent_interactions: Vec<UserInteractionWithEvent>,
}

/// User interaction with event details included.
///
/// # Purpose
/// When showing interaction history, we want to display the event title
/// and category, not just the event ID. This struct joins interaction
/// data with event data for richer context.
///
/// # Database Query
/// This is populated by a JOIN query:
/// ```sql
/// SELECT ui.interaction_type, e.title, e.category, ui.created_at
/// FROM user_interactions ui
/// JOIN events e ON ui.event_id = e.id
/// WHERE ui.user_id = $1
/// ```
///
/// # Example JSON
/// ```json
/// {
///   "interaction_type": "view",
///   "event_title": "Jazz Night at The Blue Note",
///   "event_category": "music",
///   "created_at": "2026-01-17T20:00:00Z"
/// }
/// ```
#[derive(Debug, Serialize, Deserialize, FromRow)]
pub struct UserInteractionWithEvent {
    /// What the user did: "view", "save", "attend", "dismiss"
    pub interaction_type: String,

    /// Title of the event (from events table)
    pub event_title: String,

    /// Category of the event (from events table)
    /// Useful for inferring preferences from behavior
    pub event_category: Option<String>,

    /// When the interaction happened
    pub created_at: DateTime<Utc>,
}